import os
import gdspy
import meshio
import pygmsh
import collections

from yuna.poly_ops import convert_nparray_to_list
from yuna.utils import nm


class MetaMask(type):

    _ID = 0

    @classmethod
    def __prepare__(cls, name, bases, **kwds):
        return collections.OrderedDict()

    def __new__(cls, name, bases, attrs):
        cls = super().__new__(cls, name, bases, dict(attrs))

        if 'id' in attrs:
            cls.id = '{}_{}'.format('surface', attrs['id'])
        else:
            cls.id = '{}_{}'.format(name, MetaMask._ID)
            MetaMask._ID += 1

        for key, value in attrs.items():
            setattr(cls, key, value)
            # cls.__dict__[key] = value

        if not hasattr(cls, 'registry'):
            cls.registry = {}

        cls.registry[name] = cls

        return cls

    def __init__(cls, name, bases, attrs):
        super().__init__(name, bases, dict(attrs))

    def __call__(cls, *args, **kwargs):
        cls = super().__call__(*args, **kwargs)
        return cls


SCALE = nm * 10000 * 1.0


class MaskPolygon(gdspy.PolygonSet, metaclass=MetaMask):

    def __init__(self, polygons, **kwargs):

        if kwargs:
            self.layer = kwargs['layer']
            self.datatype = kwargs['datatype']
        else:
            self.layer = 0
            self.datatype = 0

        verbose = False

        self.extrude = []
        self.volume = []

        super().__init__(polygons, layer=self.layer,
                         datatype=self.datatype, verbose=verbose)

    def __str__(self):
        return ("Yuna -> PolygonSet ({} polygons, {} vertices, layers {}, "
                "datatypes {})").format(
                len(self.polygons), sum([len(p) for p in self.polygons]),
                list(set(self.layers)), list(set(self.datatypes)))

    def __add__(self, other):
        if self.layer == other.layer:
            pass
        else:
            raise ValueError('To add masks the polygon layers must be the same.')

    def vertical_position(self, material_stack):

        print('*** vertical positioning')
        print(self.rank)

#         fixed = [True for v in dir(self) if 'start' in v]

        if self.rank >= 3:
            start = material_stack[3][0]['start'] * 2.0

            for i in range(3, self.rank):
                print(i)
                if i in material_stack:
                    start += material_stack[i][0]['width'] * 2.0
                    print('original: {}'.format(start))
                    self.width *= 1
        else:
            start = 0.0
            for i in range(self.rank):
                if i in material_stack:
                    start += material_stack[i][0]['width'] * 2.0
                    self.width *= 1

        print('start coord: {}'.format(start))

        z = start * SCALE

        return z

    def geom_surfaces(self, geom, surfaces, material_stack):
        """
        Create a list of GMSH surfaces from the mask polygons
        generated by the Yuna package.

        Arguments
        ---------
        surfaces : list
            List of pygmsh surface objects.
        """

        print('Number of polygons {}'.format(len(self.polygons)))

        for i, points in enumerate(self.polygons):
            surface_label = '{}_{}_{}'.format(self.layer, self.datatype, i)

            z = self.vertical_position(material_stack)

            pp = convert_nparray_to_list(points, z)

            gp = geom.add_polygon(pp, lcar=1.0, make_surface=True)
            geom.add_physical_surface(gp.surface, label=surface_label)

            surfaces.append(gp.surface)

    def geom_extrude(self, geom, surfaces):
        """
        This extrudes the surface to a 3D volume element.
        """

        print('extruding volume id {}'.format(self.id))

        print('Number of surfaces {}'.format(len(surfaces)))

        for i, surface in enumerate(surfaces):
            width = float(self.width) * SCALE * 2.0
            ex = geom.extrude(surface, [0, 0, width])

            unique_id = '{}_{}'.format(self.id, i)

            volume = geom.add_physical_volume(ex[1], unique_id)

            self.extrude.append(ex[1])
            self.volume.append(volume)

    def get(self):
        return gdspy.PolygonSet(self.polygons, self.layer, self.datatype)




